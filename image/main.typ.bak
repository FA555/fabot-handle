#{
  /// ====== Utils ======
  let str-to-array = s => s.split("").slice(1, -1)
  
  /// ====== Config ======
  
  let SERIF-FONTS = ("STIX Two Text", "Source Han Serif SC")
  let MONO-FONTS = ("Fira Code", "PingFang SC")
  
  let TONES = str-to-array("01234")
  let INITIALS = str-to-array("bpmfdtnlgkhjqxzcsrwy")
  let SPECIAL-INITIALS = str-to-array("zcs")
  
  let MAXIMUM-ATTEMPT-COUNT = 10
  
  /// ====== Styles ======
  
  set text(font: SERIF-FONTS)
  
  set page(
    height: auto,
    width: auto,
    margin: 1em,
  )
  
  show grid.cell: it => box(
    height: 4em,
    width: 4em,
    fill: rgb("#f7f8fa"),
    it,
  )
  
  /// ====== Models ======
  
  let State = (
    missing: "missing",
    misplaced: "misplaced",
    correct: "correct",
  )
  
  /// ====== Data ======
  
  let json-path = sys.inputs.at("path", default: "./mock-data.json")
  let data = json(json-path)

  repr(data)
  
  pagebreak()
  
  let extract = it => str-to-array(it.word).zip(
    it.pinyin.split(" ").map(pinyin => {
      let tone = if pinyin.last() in TONES {
        let tone = pinyin.last()
        if tone != "0" {
          tone
        }
        pinyin = pinyin.slice(0, -1)
      }
      
      let pronounciation = pinyin
      
      let initial = if pinyin.first() in INITIALS {
        let initial = pinyin.first()
        let count = 1
        if initial in SPECIAL-INITIALS and pinyin.len() > 1 and pinyin.at(1) == "h" {
          initial = initial + "h"
          count += 1
        }
        
        initial
        pinyin = pinyin.slice(count)
      }
      
      (
        pronounciation: pronounciation,
        initial: initial,
        vowel: pinyin,
        tone: tone,
      )
    }),
  ).map(arr => {
    (
      literal: arr.at(0),
      pinyin: arr.at(1),
    )
  })
  
  let calc-count = it => {
    let count = (
      literal: (:),
      pronounciation: (:),
      initial: (:),
      vowel: (:),
      tone: (:),
    )
    
    for character in it {
      count.literal.insert(
        character.literal,
        count.literal.at(character.literal, default: 0) + 1,
      )
      
      count.pronounciation.insert(
        character.pinyin.pronounciation,
        count.pronounciation.at(character.pinyin.pronounciation, default: 0) + 1,
      )
      
      if character.pinyin.initial != none {
        count.initial.insert(
          character.pinyin.initial,
          count.initial.at(character.pinyin.initial, default: 0) + 1,
        )
      }
      
      count.vowel.insert(
        character.pinyin.vowel,
        count.vowel.at(character.pinyin.vowel, default: 0) + 1,
      )
      
      if character.pinyin.tone != none {
        count.tone.insert(
          character.pinyin.tone,
          count.tone.at(character.pinyin.tone, default: 0) + 1,
        )
      }
    }
    
    count
  }
  
  let round = (answer, answer-count, attempt) => {
    attempt = attempt.map(it => {
      it.result = (
        whole: State.missing,
        initial: State.missing,
        vowel: State.missing,
        tone: State.missing,
      )
      
      it
    })
    
    for (i, v) in attempt.enumerate() {
      if v.literal == answer.at(i).literal {
        attempt.at(i).result.whole = State.correct
        
        answer-count.literal.insert(
          v.literal,
          answer-count.literal.at(v.literal) - 1,
        )
        
        answer-count.pronounciation.insert(
          v.pinyin.pronounciation,
          answer-count.pronounciation.at(v.pinyin.pronounciation) - 1,
        )
        
        if v.pinyin.initial != none {
          answer-count.initial.insert(
            v.pinyin.initial,
            answer-count.initial.at(v.pinyin.initial) - 1,
          )
        }
        
        answer-count.vowel.insert(
          v.pinyin.vowel,
          answer-count.vowel.at(v.pinyin.vowel) - 1,
        )
        
        if v.pinyin.tone != none {
          answer-count.tone.insert(
            v.pinyin.tone,
            answer-count.tone.at(v.pinyin.tone) - 1,
          )
        }
        
        continue
      }
    }
    
    return (answer-count, attempt)
  }
  
  /// ====== Calculation ======
  
  data.answer = extract(data.answer)
  data.attempts = data.attempts.map(extract)
  
  data.answer-count = calc-count(data.answer)
  
  raw(repr(data))
  
  for attempt in data.attempts {
    let attempt-result
    (data.answer-count, attempt-result) = round(
      data.answer,
      data.answer-count,
      attempt,
    )
    
    page[
      data.answer-count = #repr(data.answer-count)
      
      attempt = #repr(attempt)
      
      attempt-result = #repr(attempt-result)
    ]
  }
  
  pagebreak()
  
  /// ====== Content ======
  
  grid(
    columns: 4,
    rows: calc.min(data.attempts.len() + 1, MAXIMUM-ATTEMPT-COUNT),
    column-gutter: .5em,
    row-gutter: .5em,
  )
  
  align(center)[1 \/ 10]
}
